\section{Erasure codes}

\label{sec:codes}

We write $(k,n-k)$ for the parameters of MDS codes, such as \iac{rs} codes~\autocite{reed-solomon}, where $k$ is the number of data blocks and $n-k$ is the number of parity blocks. The parameters of \acp{lrc} are  $(k,n-k,r)$, where $r$ is the block locality. A block locality of $r$ means that any block is a function of at most $r$ other blocks \autocite{XorbasVLDB}. Correcting a single erased block using $(k,n-k,r)$ requires to fetch only $r$ blocks. Since we target distributed storage, we consider systematic erasure-correcting codes, although our work seamlessly extends to non-systematic codes. Extending ErasureBench to consider other types of errors would require more work.

We emphasize again that we can use ErasureBench with any erasure coding scheme. This being said, to test our platform, we focus on the following three schemes:
\begin{description}[\IEEEsetlabelwidth{XOR}]
\item[\textbf{NC}] A $(10,0)$ \emph{no coding} scheme, with 10 data blocks per stripe, that simply forwards data blocks without redundancy.
\item[\textbf{\acs{rs}}] A $(10,4)$ \acf{rs} code. We use the Vandermonde-RS implementation provided in~\autocite{XorbasVLDB}.  
\item[\textbf{\acs{lrc}}] The $(10,6,5)$ \acs{lrc} from \autocite{XorbasVLDB}. This code is optimal for the given parameters, and we use the open-source implementation from the authors.
\end{description}
