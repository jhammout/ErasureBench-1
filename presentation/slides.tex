\colorformatcornflowerblue
\setbeamercovered{transparent}

\begin{document}

% -------------------------------------------------------------------------------
% -------------------------------------------------------------------------------

\begin{frame}[plain]
  
\titlepage

\begin{center}
\includegraphics[scale=0.45]{unine}
\end{center}

\end{frame}

% -------------------------------------------------------------------------------
% -------------------------------------------------------------------------------

\subtitle[Introduction]{Introduction}

\begin{frame}{Motivation}
    More and more data needs to be stored reliably on online servers.
    Reliability can be provided through:
    \begin{itemize}
        \item<1> Replication
        \item<1-2> Erasure coding
    \end{itemize}
\end{frame}

\begin{frame}{Motivation}
    The characteristics of an erasure coding algorithm are difficult to evaluate.\\
    Evaluation is often done theoretically or by simulation.
\end{frame}

\begin{frame}{Erasure coding}
    \begin{snugshade}
        Goal: add redundancy to cope with data loss/corruption
    \end{snugshade}

    Example using a $\left(5,2\right)$ Reed-Solomon code:
    \begin{figure}
    \input{erasure-coding-figure.tex}
    \end{figure}
\end{frame}

\subtitle{Description}

\begin{frame}{Key features}
    \begin{itemize}
        \item Compatible with existing benchmark programs
        \item Automated benchmarks execution
        \item Containerized storage nodes ($>1$ per physical node)
        \item Replay fault traces
    \end{itemize}
\end{frame}

\begin{frame}{Evaluation example}
    How to evaluate a new algorithm.
    \begin{enumerate}
        \item Program the algorithm as a Java class
        \item Write benchmarks as Python functions
        \begin{itemize}
            \item Debian-compatible programs can be launched as sub-processes
        \end{itemize}
        \item Configure the evaluation
        \begin{itemize}
            \item e.g. algorithm parameters, fault trace, ...
        \end{itemize}
        \item Easily deploy the solution to a Docker cluster
        \item Collect results
    \end{enumerate}
\end{frame}

\subtitle[Architecture]{Architecture}

\begin{frame}{Technical components}
    \centering
    \input{../paper/architecture-figure.tex}
\end{frame}

\begin{frame}{Blocks distribution}
    \centering
    \input{../paper/blocks-figure.tex}
\end{frame}

\begin{frame}{Metadata management}
    Each block is identified by a 32-bit key.
    Using it, we derive:
    \begin{enumerate}
        \item Key of the blocks aggregation stored in Redis
        \item Offset within that aggregation
    \end{enumerate}
    
    The list of all block keys is kept in memory.
\end{frame}

\begin{frame}{Automated deployment and scaling}
    As part of \sys, we provide scripts that completely automate 
\end{frame}

\subtitle[Evaluation]{Evaluation}

\begin{frame}{Evaluation}
    We evaluated algorithms from "XORing Elephants: Novel Erasure Codes for Big Data".
    \begin{description}
        \item[NC] No erasure coding
        \item[RS] Reed-Solomon $(10,4)$
        \item[LRC] Locally Repairable Code $(10,6,5)$
    \end{description}
\end{frame}

\subtitle[Conclusion]{Conclusion}

\begin{frame}{Conclusion}
    Using \sys, evaluating an erasure coding algorithm under real conditions is easier and cheaper.
    \begin{itemize}
        \item Todo
    \end{itemize}
    
    Available open-source at \url{https://github.com/safecloud-project/erasurebench}
\end{frame}

% -------------------------------------------------------------------------------
% -------------------------------------------------------------------------------

\end{document}

% -------------------------------------------------------------------------------
